{"hash":"752c6ce69aa6bc2761e11346ad248f842b46c834","data":{"post":{"title":"Rodando docker compose sem root e containers com live-reload no Fedora","slug":"docker-compose-sem-root-live-reload","datetime":"2023-08-14 10:00:00","content":"<p>Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:\nmonolito legado, novo front end em React e nova API com FastAPI. Com a chegada\nde uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas\nas aplicações juntas, incluindo o banco de dados e aplicação de autenticação, o\nque facilitaria bastante o fluxo de desenvolvimento por não ter que configurar\nmanualmente todas as aplicações nem ter que subir uma por uma toda vez.</p>\n<p>Meu principal requisito era criar um docker-compose de modo que os serviços\nfossem atualizados automaticamente sem precisar buildar o container a cada\nmudança, vulgo <strong>live-reload</strong>. O método que escolhi pra fazer isso foi com\nvolumes, já que pareceu a opção mais natural: docker espelha os arquivos de uma\npasta local com os arquivos do ambiente docker, assim qualquer modificação nos\nvolumes serão compartilhadas com os containers sem a necessidade de\nreconstruir-los.</p>\n<p>Como um teste simples inicial, criei uma aplicação com FastAPI, com um único\nendpoint o mais simples possível:</p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"># src/main.py</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">from typing import Optional</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">from fastapi import FastAPI</code></p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">app = FastAPI()</code></p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">@app.get(&quot;/&quot;)</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">def read_root():</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">return {&quot;Hello&quot;: &quot;World&quot;}</code></p>\n<p>O Dockerfile também super simples, seguindo os passos da <a href=\"https://fastapi.tiangolo.com/deployment/docker/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">documentação do\nFastAPI</a>:</p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"># Dockerfile</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">FROM python:3.9</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">WORKDIR /code</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">COPY ./requirements.txt /code/requirements.txt</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">COPY ./app /code/app</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">EXPOSE 8000</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"># A opção --reload é que faz o servidor recarregar quando há mudanças nos arquivos</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--reload&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]</code></p>\n<p>E no docker-compose, o segredo tá na configuração dos volumes:</p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"># docker-compose.yml</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">version: &#039;3.7&#039;</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">services:</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">server:</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">container_name: server</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">build:</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">context: .</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">dockerfile: Dockerfile</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">volumes:</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">- ./app:/code/app</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">ports:</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">- &quot;8008:8008&quot;</code></p>\n<p>Aqui estamos dizendo que a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">app</code>, que nesse caso está no mesmo nível do\narquivo <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose.yml</code> vai ser espelhada na pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code> dentro do\ncontainer. Se você reparar no Dockerfile eu copio a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">./app</code> para\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code>, assim o conteúdo das duas deveria ser o mesmo e é exatamente onde\nestão os arquivos que eu modifico e que gostaria durante o desenvolvimento e que\ngostaria que o servidor recarregasse ao serem modificados.</p>\n<p>A princípio isso deveria funcionar, encontrei vários exemplos que faziam\nexatemente isso e pareciam bem simples, mas por algum motivo não funcionava pra\nmim. Assim que eu configurava o volume, as aplicações não funcionavam mais e\ninvestigando um pouco parecia que os arquivos ou não eram mais copiados para o\ncontainer ou o container não tinha permissão de lê-los.</p>\n<p>Como eu uso Fedora, no lugar Docker eu uso Podman, mas para docker compose usava\no pacote <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose</code> mesmo e tinha que rodar docker-compose com sudo, o que\nnão era exatamente ideal já que uma das melhores vantagens do podman (além de\nser open source) é a possibilidade de rodar docker sem root. Comecei a achar que\no problema deveria estar relacionado a isso, já que tinha cara de problema de\npermissões. Depois de postergar por meses, resolvi finalmente parar pra resolver\nisso e passar a rodar docker-compose sem root. Essa foi a primeira parte da\nsolução, o que eu não contava é que em um artigo só eu acharia a solução para os\ndois problemas: <a href=\"https://brandonrozek.com/blog/rootless-docker-compose-podman/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://brandonrozek.com/blog/rootless-docker-compose-podman/</a></p>\n<p>A solução veio em duas etapas, passar a rodar o socket do podman como meu\nusuário e não mais com root:</p>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">systemctl --user enable podman.socket</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">systemctl --user start podman.socket</code>\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">export DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock</code></p>\n<p>E no finalzinho do artigo, Brandon solta essa informação despretenciosamente que\nfoi o que me salvou:</p>\n<blockquote>\n<p>\"If you want to add to add more volumes to the container, make sure it has the\nappropriate SELinux label if you’re using a distribution with it enabled.\"</p>\n</blockquote>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R &lt;volume_name&gt;</code></p>\n<p>No caso do meu exemplo, <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R app</code> foi o que resolveu.</p>\n<p>Eu quebrei muita a cabeça até achar essa solução e finalmente consigo rodar\ndocker-compose sem root e usar live-reload!</p>\n<p>Segue o repositório bem simples com exemplo que descrevi:\n<a href=\"https://github.com/anarute/fastapi-live-reload\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/anarute/fastapi-live-reload</a></p>\n<p>Se quiser ler um pouco mais sobre, recomendo <a href=\"https://www.freecodecamp.org/news/how-to-enable-live-reload-on-docker-based-applications/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">esse\nartigo</a>\ndo Erick Wendel.</p>\n","description":"","cover":"","fullscreen":false,"author":{"id":"anarute","title":"anarute","path":"/author/anarute/"},"tags":[{"id":"pt-br","title":"pt-br","path":"/tag/pt-br/"},{"id":"docker","title":"docker","path":"/tag/docker/"},{"id":"fedora","title":"fedora","path":"/tag/fedora/"}]}},"context":{}}