{"hash":"752c6ce69aa6bc2761e11346ad248f842b46c834","data":{"tag":{"id":"docker","title":"docker","path":"/tag/docker/","belongsTo":{"totalCount":1,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"233e353d5ce5d8b3e281b4571f0b2e5d","title":"Rodando docker compose sem root e containers com live-reload no Fedora","datetime":"2023-08-14 10:00:00","path":"/docker-compose-sem-root-live-reload/","content":"<p>Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:\nmonolito legado, novo front end em React e nova API com FastAPI. Com a chegada\nde uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas\nas aplicações juntas, incluindo o banco de dados e aplicação de autenticação, o\nque facilitaria bastante o fluxo de desenvolvimento por não ter que configurar\nmanualmente todas as aplicações nem ter que subir uma por uma toda vez.</p>\n<p>Meu principal requisito era criar um docker-compose de modo que os serviços\nfossem atualizados automaticamente sem precisar buildar o container a cada\nmudança, vulgo <strong>live-reload</strong>. O método que escolhi pra fazer isso foi com\nvolumes, já que pareceu a opção mais natural: docker espelha os arquivos de uma\npasta local com os arquivos do ambiente docker, assim qualquer modificação nos\nvolumes serão compartilhadas com os containers sem a necessidade de\nreconstruir-los.</p>\n<p>Como um teste simples inicial, criei uma aplicação com FastAPI, com um único\nendpoint o mais simples possível:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># src/main.py`</span>\n\n<span style=\"color: #D32F2F\">from</span><span style=\"color: #24292EFF\"> typing </span><span style=\"color: #D32F2F\">import</span><span style=\"color: #24292EFF\"> Optional</span>\n<span style=\"color: #D32F2F\">from</span><span style=\"color: #24292EFF\"> fastapi </span><span style=\"color: #D32F2F\">import</span><span style=\"color: #24292EFF\"> FastAPI</span>\n\n<span style=\"color: #24292EFF\">app </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">FastAPI()</span>\n\n<span style=\"color: #6F42C1\">@app.get</span><span style=\"color: #24292EFF\">(</span><span style=\"color: #22863A\">\"/\"</span><span style=\"color: #24292EFF\">)</span>\n<span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">read_root</span><span style=\"color: #24292EFF\">():</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">return</span><span style=\"color: #24292EFF\"> {</span><span style=\"color: #22863A\">\"Hello\"</span><span style=\"color: #24292EFF\">: </span><span style=\"color: #22863A\">\"World\"</span><span style=\"color: #24292EFF\">}</span></code></pre>\n<p>O Dockerfile também super simples, seguindo os passos da <a href=\"https://fastapi.tiangolo.com/deployment/docker/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">documentação do\nFastAPI</a>:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># Dockerfile</span>\n\n<span style=\"color: #24292EFF\">FROM python:</span><span style=\"color: #1976D2\">3.9</span>\n\n<span style=\"color: #24292EFF\">WORKDIR </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span>\n\n<span style=\"color: #24292EFF\">COPY .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt</span>\n\n<span style=\"color: #24292EFF\">RUN pip install --no</span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\">cache</span><span style=\"color: #D32F2F\">-</span><span style=\"color: #1976D2\">dir</span><span style=\"color: #24292EFF\"> --upgrade </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\">r </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt</span>\n\n<span style=\"color: #24292EFF\">COPY .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app</span>\n\n<span style=\"color: #24292EFF\">EXPOSE </span><span style=\"color: #1976D2\">8000</span>\n\n<span style=\"color: #6A737D\"># A opção --reload é que faz o servidor recarregar quando há mudanças nos arquivos</span>\n\n<span style=\"color: #24292EFF\">CMD [</span><span style=\"color: #22863A\">\"uvicorn\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"app.main:app\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--reload\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--host\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"0.0.0.0\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--port\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"8000\"</span><span style=\"color: #24292EFF\">]</span></code></pre>\n<p>E no docker-compose, o segredo tá na configuração dos volumes:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># docker-compose.yml</span>\n\n<span style=\"color: #24292EFF\">version: </span><span style=\"color: #22863A\">'3.7'</span>\n\n<span style=\"color: #24292EFF\">services:</span>\n<span style=\"color: #24292EFF\">  server:</span>\n<span style=\"color: #24292EFF\">    container_name: server</span>\n<span style=\"color: #24292EFF\">    build:</span>\n<span style=\"color: #24292EFF\">      context: .</span>\n<span style=\"color: #24292EFF\">      dockerfile: Dockerfile</span>\n<span style=\"color: #24292EFF\">    volumes:</span>\n<span style=\"color: #24292EFF\">      </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\"> .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app:</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app</span>\n<span style=\"color: #24292EFF\">    ports:</span>\n<span style=\"color: #24292EFF\">      </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #22863A\">\"8008:8008\"</span></code></pre>\n<p>Aqui estamos dizendo que a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">app</code>, que nesse caso está no mesmo nível do\narquivo <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose.yml</code> vai ser espelhada na pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code> dentro do\ncontainer. Se você reparar no Dockerfile eu copio a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">./app</code> para\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code>, assim o conteúdo das duas deveria ser o mesmo e é exatamente onde\nestão os arquivos que eu modifico e que gostaria durante o desenvolvimento e que\ngostaria que o servidor recarregasse ao serem modificados.</p>\n<p>A princípio isso deveria funcionar, encontrei vários exemplos que faziam\nexatemente isso e pareciam bem simples, mas por algum motivo não funcionava pra\nmim. Assim que eu configurava o volume, as aplicações não funcionavam mais e\ninvestigando um pouco parecia que os arquivos ou não eram mais copiados para o\ncontainer ou o container não tinha permissão de lê-los.</p>\n<p>Como eu uso Fedora, no lugar Docker eu uso Podman, mas para docker compose usava\no pacote <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose</code> mesmo e tinha que rodar docker-compose com sudo, o que\nnão era exatamente ideal já que uma das melhores vantagens do podman (além de\nser open source) é a possibilidade de rodar docker sem root. Comecei a achar que\no problema deveria estar relacionado a isso, já que tinha cara de problema de\npermissões. Depois de postergar por meses, resolvi finalmente parar pra resolver\nisso e passar a rodar docker-compose sem root. Essa foi a primeira parte da\nsolução, o que eu não contava é que em um artigo só eu acharia a solução para os\ndois problemas: <a href=\"https://brandonrozek.com/blog/rootless-docker-compose-podman/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://brandonrozek.com/blog/rootless-docker-compose-podman/</a></p>\n<p>A solução veio em duas etapas, passar a rodar o socket do podman como meu\nusuário e não mais com root:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #24292EFF\">systemctl --user </span><span style=\"color: #1976D2\">enable</span><span style=\"color: #24292EFF\"> podman.socket</span>\n<span style=\"color: #24292EFF\">systemctl --user start podman.socket</span>\n<span style=\"color: #D32F2F\">export</span><span style=\"color: #24292EFF\"> DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock</span></code></pre>\n<p>E no finalzinho do artigo, Brandon solta essa informação despretenciosamente que\nfoi o que me salvou:</p>\n<blockquote>\n<p>\"If you want to add to add more volumes to the container, make sure it has the\nappropriate SELinux label if you’re using a distribution with it enabled.\"</p>\n</blockquote>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R &lt;volume_name&gt;</code></p>\n<p>No caso do meu exemplo, <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R app</code> foi o que resolveu.</p>\n<p>Eu quebrei muita a cabeça até achar essa solução e finalmente consigo rodar\ndocker-compose sem root e usar live-reload!</p>\n<p>Segue o repositório bem simples com exemplo que descrevi:\n<a href=\"https://github.com/anarute/fastapi-live-reload\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/anarute/fastapi-live-reload</a></p>\n<p>Se quiser ler um pouco mais sobre, recomendo <a href=\"https://www.freecodecamp.org/news/how-to-enable-live-reload-on-docker-based-applications/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">esse\nartigo</a>\ndo Erick Wendel.</p>\n","excerpt":"","description":"","author":{"id":"anarute","title":"anarute","path":"/author/anarute/"}}}]}}},"context":{}}