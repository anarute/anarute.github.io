{"hash":"752c6ce69aa6bc2761e11346ad248f842b46c834","data":{"tag":{"id":"pt-br","title":"pt-br","path":"/tag/pt-br/","belongsTo":{"totalCount":3,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"233e353d5ce5d8b3e281b4571f0b2e5d","title":"Rodando docker compose sem root e containers com live-reload no Fedora","datetime":"2023-08-14 10:00:00","path":"/docker-compose-sem-root-live-reload/","content":"<p>Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:\nmonolito legado, novo front end em React e nova API com FastAPI. Com a chegada\nde uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas\nas aplicações juntas, incluindo o banco de dados e aplicação de autenticação, o\nque facilitaria bastante o fluxo de desenvolvimento por não ter que configurar\nmanualmente todas as aplicações nem ter que subir uma por uma toda vez.</p>\n<p>Meu principal requisito era criar um docker-compose de modo que os serviços\nfossem atualizados automaticamente sem precisar buildar o container a cada\nmudança, vulgo <strong>live-reload</strong>. O método que escolhi pra fazer isso foi com\nvolumes, já que pareceu a opção mais natural: docker espelha os arquivos de uma\npasta local com os arquivos do ambiente docker, assim qualquer modificação nos\nvolumes serão compartilhadas com os containers sem a necessidade de\nreconstruir-los.</p>\n<p>Como um teste simples inicial, criei uma aplicação com FastAPI, com um único\nendpoint o mais simples possível:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># src/main.py</span>\n\n<span style=\"color: #D32F2F\">from</span><span style=\"color: #24292EFF\"> typing </span><span style=\"color: #D32F2F\">import</span><span style=\"color: #24292EFF\"> Optional</span>\n<span style=\"color: #D32F2F\">from</span><span style=\"color: #24292EFF\"> fastapi </span><span style=\"color: #D32F2F\">import</span><span style=\"color: #24292EFF\"> FastAPI</span>\n\n<span style=\"color: #24292EFF\">app </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">FastAPI()</span>\n\n<span style=\"color: #6F42C1\">@app.get</span><span style=\"color: #24292EFF\">(</span><span style=\"color: #22863A\">\"/\"</span><span style=\"color: #24292EFF\">)</span>\n<span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">read_root</span><span style=\"color: #24292EFF\">():</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">return</span><span style=\"color: #24292EFF\"> {</span><span style=\"color: #22863A\">\"Hello\"</span><span style=\"color: #24292EFF\">: </span><span style=\"color: #22863A\">\"World\"</span><span style=\"color: #24292EFF\">}</span></code></pre>\n<p>O Dockerfile também super simples, seguindo os passos da <a href=\"https://fastapi.tiangolo.com/deployment/docker/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">documentação do\nFastAPI</a>:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># Dockerfile</span>\n\n<span style=\"color: #24292EFF\">FROM python:</span><span style=\"color: #1976D2\">3.9</span>\n\n<span style=\"color: #24292EFF\">WORKDIR </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span>\n\n<span style=\"color: #24292EFF\">COPY .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt</span>\n\n<span style=\"color: #24292EFF\">RUN pip install --no</span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\">cache</span><span style=\"color: #D32F2F\">-</span><span style=\"color: #1976D2\">dir</span><span style=\"color: #24292EFF\"> --upgrade </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\">r </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">requirements.txt</span>\n\n<span style=\"color: #24292EFF\">COPY .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app </span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app</span>\n\n<span style=\"color: #24292EFF\">EXPOSE </span><span style=\"color: #1976D2\">8000</span>\n\n<span style=\"color: #6A737D\"># A opção --reload é que faz o servidor recarregar quando há mudanças nos arquivos</span>\n\n<span style=\"color: #24292EFF\">CMD [</span><span style=\"color: #22863A\">\"uvicorn\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"app.main:app\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--reload\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--host\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"0.0.0.0\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"--port\"</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"8000\"</span><span style=\"color: #24292EFF\">]</span></code></pre>\n<p>E no docker-compose, o segredo tá na configuração dos volumes:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6A737D\"># docker-compose.yml</span>\n\n<span style=\"color: #24292EFF\">version: </span><span style=\"color: #22863A\">'3.7'</span>\n\n<span style=\"color: #24292EFF\">services:</span>\n<span style=\"color: #24292EFF\">  server:</span>\n<span style=\"color: #24292EFF\">    container_name: server</span>\n<span style=\"color: #24292EFF\">    build:</span>\n<span style=\"color: #24292EFF\">      context: .</span>\n<span style=\"color: #24292EFF\">      dockerfile: Dockerfile</span>\n<span style=\"color: #24292EFF\">    volumes:</span>\n<span style=\"color: #24292EFF\">      </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\"> .</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app:</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">code</span><span style=\"color: #D32F2F\">/</span><span style=\"color: #24292EFF\">app</span>\n<span style=\"color: #24292EFF\">    ports:</span>\n<span style=\"color: #24292EFF\">      </span><span style=\"color: #D32F2F\">-</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #22863A\">\"8008:8008\"</span></code></pre>\n<p>Aqui estamos dizendo que a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">app</code>, que nesse caso está no mesmo nível do\narquivo <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose.yml</code> vai ser espelhada na pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code> dentro do\ncontainer. Se você reparar no Dockerfile eu copio a pasta <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">./app</code> para\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">/code/app</code>, assim o conteúdo das duas deveria ser o mesmo e é exatamente onde\nestão os arquivos que eu modifico e que gostaria durante o desenvolvimento e que\ngostaria que o servidor recarregasse ao serem modificados.</p>\n<p>A princípio isso deveria funcionar, encontrei vários exemplos que faziam\nexatemente isso e pareciam bem simples, mas por algum motivo não funcionava pra\nmim. Assim que eu configurava o volume, as aplicações não funcionavam mais e\ninvestigando um pouco parecia que os arquivos ou não eram mais copiados para o\ncontainer ou o container não tinha permissão de lê-los.</p>\n<p>Como eu uso Fedora, no lugar Docker eu uso Podman, mas para docker compose usava\no pacote <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">docker-compose</code> mesmo e tinha que rodar docker-compose com sudo, o que\nnão era exatamente ideal já que uma das melhores vantagens do podman (além de\nser open source) é a possibilidade de rodar docker sem root. Comecei a achar que\no problema deveria estar relacionado a isso, já que tinha cara de problema de\npermissões. Depois de postergar por meses, resolvi finalmente parar pra resolver\nisso e passar a rodar docker-compose sem root. Essa foi a primeira parte da\nsolução, o que eu não contava é que em um artigo só eu acharia a solução para os\ndois problemas: <a href=\"https://brandonrozek.com/blog/rootless-docker-compose-podman/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://brandonrozek.com/blog/rootless-docker-compose-podman/</a></p>\n<p>A solução veio em duas etapas, passar a rodar o socket do podman como meu\nusuário e não mais com root:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #24292EFF\">systemctl --user </span><span style=\"color: #1976D2\">enable</span><span style=\"color: #24292EFF\"> podman.socket</span>\n<span style=\"color: #24292EFF\">systemctl --user start podman.socket</span>\n<span style=\"color: #D32F2F\">export</span><span style=\"color: #24292EFF\"> DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock</span></code></pre>\n<p>E no finalzinho do artigo, Brandon solta essa informação despretenciosamente que\nfoi o que me salvou:</p>\n<blockquote>\n<p>\"If you want to add to add more volumes to the container, make sure it has the\nappropriate SELinux label if you’re using a distribution with it enabled.\"</p>\n</blockquote>\n<p><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R &lt;volume_name&gt;</code></p>\n<p>No caso do meu exemplo, <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">chcon -t container_file_t -R app</code> foi o que resolveu.</p>\n<p>Eu quebrei muita a cabeça até achar essa solução e finalmente consigo rodar\ndocker-compose sem root e usar live-reload!</p>\n<p>Segue o repositório bem simples com exemplo que descrevi:\n<a href=\"https://github.com/anarute/fastapi-live-reload\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/anarute/fastapi-live-reload</a></p>\n<p>Se quiser ler um pouco mais sobre, recomendo <a href=\"https://www.freecodecamp.org/news/how-to-enable-live-reload-on-docker-based-applications/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">esse\nartigo</a>\ndo Erick Wendel.</p>\n","excerpt":"","description":"","author":{"id":"anarute","title":"anarute","path":"/author/anarute/"}}},{"node":{"id":"19990dbc24ab8f305e1f1ee95a99f671","title":"Primeiros passos com Next.js","datetime":"2020-09-19 10:00:00","path":"/primeiros-passos-com-nextjs/","content":"<p>Cerca de 8 anos atrás (!), para um dos meus trabalhos finais da faculdade eu\ndesenvolvi um site que inicialmente era estátipo \"puro\" (HTML, CSS e js), virou\num Wordpress para que outras pessoas pudessem mexer no conteúdo e finalmente\nfoi abandonado com o passar do tempo a ponto de precisar ser removido ao ser\nhackeado - clássico fim de sites wordpress que não sofrem manutenção frequente.</p>\n<p>Recentemente uma das criadoras do projeto entrou em contato comigo para subirmos\no site novamente e como gosto muito do projeto, topei. Porém, terei que refazer\ndo zero, já que quero que novamente seja estático, sem ter que manter um CMS, nem\nme preocupar com manutençao de servidor, se o site pode ser hackeado, nada disso.</p>\n<p>Ao invés de fazer com js vanilla, resolvi aproveitar a oportunidade pra\nfazer em Next.js e tentar entender porque que esse framework está tão em alta.</p>\n<p>Antes de tudo é importante entender a diferença entre site estático, site\nrenderizado no cliente e renderizado no servidor. Pra isso recomendo <a href=\"https://www.youtube.com/watch?v=X3W-YFe2_io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">o excelente\nvideo do Willian Justen</a>, ele explica de forma super didática essas diferenças e quando usar cada um.</p>\n<h2 id=\"iniciando-o-projeto-em-nextjs\"><a href=\"#iniciando-o-projeto-em-nextjs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Iniciando o projeto em Next.js</h2>\n<p>De cara já fiquei super feliz com o boilerplate do Next.js. Segui a\n<a href=\"https://nextjs.org/docs#setup\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">documentação</a> e instalei usando <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">npx create-next-app</code>.\nEle já me deu esqueleto inicial com alguns páginas e até uma mini Rest API. Pro\nmeu projeto atual não vou precisar mas fiquei surpresa quando vi, pode ser bem\nútil em outros projetos.</p>\n<p>Eu gosto muito que o Next.js cuida das rotas baseado na estrutura das pastas sem\na gente precisar configurar nada.</p>\n<h2 id=\"importando-uma-biblioteca-externa-que-é-rendereziada-no-cliente\"><a href=\"#importando-uma-biblioteca-externa-que-%C3%A9-rendereziada-no-cliente\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Importando uma biblioteca externa que é rendereziada no cliente</h2>\n<p>De cara meu primeiro desafio foi lidar com o erro <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">ReferenceError: window is not defined</code>.\nEle apareceu quando tentei adicionar ao projeto uma\n<a href=\"http://wavesurfer-js.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">biblioteca externa</a> e inseri como sempre fiz em\nqualquer outro projeto React - instalei com npm/yarn, e dei o import <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">import WaveSurfer from &quot;wavesurfer.js&quot;;</code> e oops:</p>\n<p><img src=\"/images/posts/window-not-defined.png\" alt=\"Window not defined\"></p>\n<p>A principio achei bem esquisito, já que o objeto <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">window</code></a> é basicamente a porta de entrada pro DOM da janela atual\nonde o script está sendo rodado. Como assim ele não foi definido? Imaginei que\npoderia ser algo relacionado ao documento ainda não ter sido renderizado então\nadicionei o componente dentro do <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">useEffect</code>, mas continuei com o mesmo problema.\nDepois de ler um pouco sobre que me toquei que esse código provavelmente está\nsendo rodado do lado do servidor! E nesse caso não existe mesmo uma <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">window</code>.</p>\n<p>Aí veio a segunda surpresa boa: a documentação do Next.js é ótima e já tinha uma\n<a href=\"https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">seção só pra isso</a>.\nEu passei por vários artigos e respostas no stackoverflow que\nsó induziam a um ctrl+c ctrl+v sem explicar direito. No fim bastava ler a\ndocumentação para chegar na solução: o que queremos é que esse componente seja\nrenderizado apenas do lado do cliente. Pra isso basta fazer um import dinâmico\ncom a opção <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">ssr: false</code>, ou seja, sem renderizar no servidor.</p>\n<code class=\"shiki\" style=\"background: #2e3440; color: #d8dee9\">const AudioPlayer = dynamic(() =&gt; import(&quot;../components/AudioPlayer&quot;), {\n  ssr: false,\n});</code>\n<p>E o componente AudioPlayer escrevo normal como em qualquer outro projeto React.</p>\n<h2 id=\"conclusão\"><a href=\"#conclus%C3%A3o\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusão</h2>\n<p>O bom de ter lidado com esse erro logo de cara foi que me fez mudar a forma de\npensar no início do projeto e lembrar que a principal diferença do Next.js e\noutros projetos React é justamente entender que o projeto é renderizado no\nservidor ao invés do cliente, mas ao mesmo tempo ele permite esse dinamismo\nquando precisamos que algo seja renderizado no cliente, dando o melhor dos dois mundos!</p>\n","excerpt":"","description":"","author":{"id":"anarute","title":"anarute","path":"/author/anarute/"}}},{"node":{"id":"4761b34ad1a7c2ceb12101e3d2a606eb","title":"Minha saga com pytest e SQLAlchemy em uma aplicação FastAPI","datetime":"2020-07-25 10:00:00","path":"/minha-saga-com-pytest-e-sqlalchemy/","content":"<p><strong>TLDR:</strong> meu causo sobre aprender <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest</code> na marra. Os primeiros parágrafos são\nintrodutórios, se quiser pular pra parte técnica pode ir direto pro <strong>Perrengue 1</strong>.</p>\n<p>Desde que voltei a trabalhar full-time como desenvolvedora (há uns 3 anos), tive\nque reaprender muita coisa e não posso mais me dar ao luxo de continuar com\nalguns gaps teóricos importantes de computação, já que hoje ocupo uma\nposição de tech lead e por estar em um time pequeno, preciso pensar em\narquiteturas de ponta a ponta em stacks diferentes e pra mim o mais difícil:\ndo zero. Decidi então seguir a onda de aprender em público e começa a escrever\nsobre meus aprendizados, quem sabe não ajuda mais alguém que passe pelo mesmo caminho.</p>\n<p>Em quase todos os meus trabalhos passados eu sempre entrei em projetos existentes\no que torna muito mais fácil desenvolver novas features, já que temos no próprio\nrepositório exemplos de como fazer algo. Mas e quando precisamos escolher\ntodas as ferramentas e configurar tudo do início? As vezes pode ser um trabalho\nbem sofrido e moroso. É por isso que ferramentas como <a href=\"https://reactjs.org/docs/create-a-new-react-app.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Create\nReact App</a>, <a href=\"https://www.djangoproject.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Django</a>, e <a href=\"https://fastapi.tiangolo.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">FastAPI</a> (minha favorita da vez) fazem tanto sucesso.</p>\n<p>Estou trabalhando em uma API RESTFul criada com o FastAPI. Conseguimos portar uma\nAPI feita em Flask pra FastAPI em apenas ~2 semanas em duas pessoas (!), nada contra Flask, mas por ser tão minimalista, ter que configurar coisas como documentação com especificação OpenAPI, um bom suporte pra gestão do banco de dados e concorrencia estava tomando tempo e exigindo um bom tempo de estudo pra fazer uma trabalho bem feito. E foi nisso que o FastAPI nos conquistou! Ele entrega tudo isso de fábrica.</p>\n<p><strong>Disclaimer</strong>: acho super importante gastar tempo aprendendo pra fazer algo bem\npensado, mas a gente sabe que no dia a dia do trabalho a realidade é outra, né? na maior parte das vezes, independente da cultura da sua empresa, o tempo de estudo é limitado e precisamos entregar o que foi pedido num certo período de tempo.</p>\n<p>Comecei então a configurar os testes. Quando o projeto foi feito em Flask tinha\npouquissima cobertura e a configuração do <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest</code> não estava muito legal então\nresolvi jogar essa parte fora e começar o setup dos testes do zero.</p>\n<p>Eu adoro criar testes mas até então só tinha mexido na parte de escrever os casos\nde teste mesmo então sempre começava já com ctrl+c, ctrl+v de um teste existente e adaptava pro caso que queria. Também não tinha experiência com <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest</code> ainda.</p>\n<p>Vendo a documentação do FastAPI, rodar testes com <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest</code> no projeto é bem trivial, usei o exemplo padrão e funcionou de primeira, achei que tivesse pronta pra escrever os casos. O projeto usa SQLAlchemy com mysql pra produção e pros testes optei\npor sqlite.</p>\n<p>Mas aí é quando as dificuldades começam, quando precisamos adaptar pro nosso cenário.\nMinhas necessidades eram:</p>\n<ul>\n<li>Iniciar os testes com a banco populado com alguns registros</li>\n<li>O banco precisa ser limpo e populado com os valores iniciais a cada teste, pra\nque nenhum teste interfira no outro</li>\n</ul>\n<p>Achei que seria simples e acharia muitos exemplos por aí, mas conseguir o que\nqueria me custou muitas horas a mais do que eu esperava.</p>\n<h2 id=\"perrengue-1-entendendo-como-isolar-os-ambientes\"><a href=\"#perrengue-1-entendendo-como-isolar-os-ambientes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Perrengue 1 (entendendo como isolar os ambientes)</h2>\n<blockquote>\n<p>Ao rodar os testes em um ambiente limpo (no gitlab CI), dava erro por não\nconseguir se conectar ao banco.</p>\n</blockquote>\n<p>Primeiro, por que que ao rodar os testes ele tenta acessar o banco configurado no\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">.env</code> se eu configuro o sqlite espeficamente pros testes? e segundo, porque local funciona e no docker do CI não?</p>\n<p>Pela documentaçao do FastAPI, eles recomendam usar o <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">create_all</code> do SQLAlchemy\npara criar todas as tabelas <a href=\"https://fastapi.tiangolo.com/tutorial/sql-databases/#create-the-database-tables\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">antes de iniciar a aplicação</a>. O problema é que fazer\nexatamente assim faz com que o <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">create_all</code> seja chamado, só pelo fato de importar o app pros testes. Então a solução foi isolar\no <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">create_all</code> de modo que ele fosse chamado apenas ao rodar a aplicação real, e\nnão com os testes. Isso também explica porque local funcionava e no CI não: local\neu tinha as variaveis de ambiente configuradas corretamente então a conexão com\no banco era bem sucedida mesmo que pros testes fosse usado um banco sqlite.</p>\n<h2 id=\"perrengue-2-entendendo-pytestfixture\"><a href=\"#perrengue-2-entendendo-pytestfixture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Perrengue 2 (entendendo pytest.fixture)</h2>\n<blockquote>\n<p>Não consigo conectar ao banco dentro de uma pytest.fixture</p>\n</blockquote>\n<p>Eu sou super defensora de ler a documentação e li e reli a documentação do\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest.fixture</code> umas 5 vezes pra entender o que eu tinha feito errado. Mas às\nvezes mesmo lendo a documentação, se a gente não tem ideia do que está\nacontencedo a doc simplesmente não faz sentido, pelo menos acontece muito comigo,\neu leio as palavras mas nada acontece na minha cabeça, não absorvo o sentido.\nEntão o que percebi que funciona pra mim é um mix de brute force com documentação:\nlê a doc, experimenta um parâmetro ou propriedade diferente, testa e vê o que acontece, repete até entender.</p>\n<p>Baseada na doc do FastAPI, eu tentei usar a mesma função pra conectar ao banco que a aplicação usava, que é algo assim:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">get_db</span><span style=\"color: #24292EFF\">():</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">try</span><span style=\"color: #24292EFF\">:</span>\n<span style=\"color: #24292EFF\">        db </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">TestingSessionLocal()</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6A737D\"># sessão criada com sessionmaker do SQLAlchemy</span>\n<span style=\"color: #24292EFF\">        </span><span style=\"color: #D32F2F\">yield</span><span style=\"color: #24292EFF\"> db</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">finally</span><span style=\"color: #24292EFF\">:</span>\n<span style=\"color: #24292EFF\">        db.</span><span style=\"color: #6F42C1\">close()</span></code></pre>\n<p>Eu tentei fazer com que isso fosse uma fixture com o parametro <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">autouse=True</code>\npra que fosse chamada dentro de cada teste e assim eu poder usar o banco como <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">db</code>\npra importar os dados que eu queria e inserir o registros iniciais. Mas ao usar\nassim recebia o erro: </p>\n<code class=\"shiki\" style=\"background: #2e3440; color: #d8dee9\">yield_fixture function has more than one &#039;yield&#039;</code>\n<p>Hmm.. os links que o erro sugere na doc explicam bem sobre o erro acima, mas o que será uma <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">yield_fixture</code>? e foi essa dúvida que fez as mil vezes que li\na documentação fazer algum sentido! Basicamente entendi que a <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest.fixture</code> funciona como\num \"envelope\" ao redor do teste, seguindo o seguinte padrão:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6F42C1\">@pytest.fixture</span>\n<span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> minha_fixture:</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6A737D\"># insira qualquer lógica pra ser executada ANTES do teste</span>\n\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">yield</span><span style=\"color: #24292EFF\">  </span><span style=\"color: #6A737D\"># (!!) é esse yield que vai retornar o teste e faze-lo rodar</span>\n\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6A737D\"># insira a lógica de tear down, pra ser executada DEPOIS do test</span>\n\n<span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">test_case_xis</span><span style=\"color: #24292EFF\">(</span><span style=\"color: #FF9800\">minha_fixture</span><span style=\"color: #24292EFF\">):</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">assert</span><span style=\"color: #24292EFF\"> a </span><span style=\"color: #D32F2F\">==</span><span style=\"color: #24292EFF\"> b</span></code></pre>\n<p>Então a <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest.fixture</code> realmente era o que eu precisava.</p>\n<p>Quando eu chamava o <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">yield db</code> lá em cima no <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">get_db</code>, o <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest</code> tentava\nrodar o teste e nunca chegaria no segundo <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">yield</code> que roda o teste de fato,\nentão o que eu gostaria que acontecesse no setup não tava acontecendo.</p>\n<p>A solução foi bem simples, eu não precisava de uma função pra acessar o banco, bastava rodar <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">db = TestingSessionLocal()</code> onde esse <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">TestingSessionLocal</code> é uma sessão criada pelo SQLAlchemy e no tear down do teste, dar um <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">db.close()</code>. Isso resolveu meu caso\nde acessar o banco, limpa-lo e inserir os dados falsos antes de cada teste.\nFicou algo assim:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #6F42C1\">@pytest.fixture</span><span style=\"color: #24292EFF\">(</span><span style=\"color: #6F42C1\">autouse</span><span style=\"color: #D32F2F\">=</span><span style=\"color: #1976D2\">True</span><span style=\"color: #24292EFF\">)</span>\n<span style=\"color: #D32F2F\">def</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">init_db</span><span style=\"color: #24292EFF\">():</span>\n<span style=\"color: #24292EFF\">    db </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">TestingSessionLocal()</span>\n\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6A737D\"># Clean up tables before importing the initial data</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">query(MyModel)</span><span style=\"color: #24292EFF\">.</span><span style=\"color: #6F42C1\">delete()</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">commit()</span>\n\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6A737D\"># Insert mock data in the db</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">for</span><span style=\"color: #24292EFF\"> r </span><span style=\"color: #D32F2F\">in</span><span style=\"color: #24292EFF\"> fake_records:</span>\n<span style=\"color: #24292EFF\">        new_record </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">MyModel(</span><span style=\"color: #D32F2F\">**</span><span style=\"color: #6F42C1\">r)</span>\n<span style=\"color: #24292EFF\">        db.</span><span style=\"color: #6F42C1\">add(new_record)</span>\n<span style=\"color: #24292EFF\">        db.</span><span style=\"color: #6F42C1\">commit()</span>\n<span style=\"color: #24292EFF\">        db.</span><span style=\"color: #6F42C1\">refresh(new_record)</span>\n\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #D32F2F\">yield</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6A737D\"># run the test</span>\n\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">close()</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6A737D\"># close session after running the test</span></code></pre>\n<h2 id=\"perrengue-3-entendendo-como-funcionam-os-models-do-sqlalchemy\"><a href=\"#perrengue-3-entendendo-como-funcionam-os-models-do-sqlalchemy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Perrengue 3 (entendendo como funcionam os models do SQLAlchemy)</h2>\n<blockquote>\n<p>Consegui popular o banco antes de um teste, fui replicar o mesmo teste e no\nsegundo caso os valores do primeiro teste ainda estavam no banco</p>\n</blockquote>\n<p>Depois de finalmente entender como <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pytest.fixture</code> funciona, comecei a ter problemas ao inserir mais casos de teste. Usando nosso amigo <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">print</code> a impressão que dava era que a fixture só era acessada no primeiro caso. Isso me levou a pesquisar sobre\ncache de fixture, como que as fixtures era chamadas, etc, sem sucesso.</p>\n<p>Usando <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">pdb</code> eu consegui confirmar que a fixture estava sendo chamada a cada teste, então por que raios o banco não estava sendo limpo?</p>\n<p>Foi aí que comecei a desconfiar que o problema não era mais a fixture e precisei entender melhor como o SQLAlchemy lida com sessões\ne gerencia o banco em tempo de execução. Recomendo <a href=\"https://www.michaelcho.me/article/sqlalchemy-commit-flush-expire-refresh-merge-whats-the-difference\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">esse artigo</a> sobre isso.</p>\n<p>Pra inserir os dados fakes, eu criei um array com meus models já usando o model\nda aplicação, algo como:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #24292EFF\">users </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> [</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6F42C1\">MyModel(id</span><span style=\"color: #D32F2F\">=</span><span style=\"color: #1976D2\">1</span><span style=\"color: #6F42C1\">, name</span><span style=\"color: #D32F2F\">=</span><span style=\"color: #22863A\">\"ABC\"</span><span style=\"color: #6F42C1\">)</span><span style=\"color: #24292EFF\">,</span>\n<span style=\"color: #24292EFF\">    </span><span style=\"color: #6F42C1\">MyModel(id</span><span style=\"color: #D32F2F\">=</span><span style=\"color: #1976D2\">2</span><span style=\"color: #6F42C1\">, name</span><span style=\"color: #D32F2F\">=</span><span style=\"color: #22863A\">\"XYZ\"</span><span style=\"color: #6F42C1\">)</span><span style=\"color: #24292EFF\">,</span>\n<span style=\"color: #24292EFF\">]</span></code></pre>\n<p>E na minha fixture:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #D32F2F\">for</span><span style=\"color: #24292EFF\"> user </span><span style=\"color: #D32F2F\">in</span><span style=\"color: #24292EFF\"> users:</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">add(user)</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">commit()</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">refresh(user)</span></code></pre>\n<p>O primeiro teste a ser rodado SEMPRE dava certo, mas do segundo em diante não.\nEu não conseguia entender o que estava fazendo de errado até tentar entender como\no meu model estava sendo criado: o <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">MyModel</code> é uma classe que herda o Base da aplicação que no fundo é um <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">declarative_base</code> do SQLAlchemy. Ah-há! eu\nachava que eu estava só declarando um array de objetos do tipo MyModel, mas na\nverdade ao criar esse array o SQLAlchemy já estava instanciando esses objetos\ncomo parte dos dados da sessão aberta mesmo que eles não tivessem sido inseridos no banco!</p>\n<p>Então ao rodar esse <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">for</code> mais de uma vez o SQLAlchemy reclamava porque o objeto já tinha sido inserido em algum momento então ele não inseria de novo, por isso eu lidava com erros como:\n<code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">Object already attached to session</code> ou <code class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\">sqlalchemy.exc.InvalidRequestError: Could not refresh instance</code>. Tudo porque eu estava tentando inserir um objeto que ja tinha sido\ninserido no banco E já tinha sido deletado, porque eu deleto tudo antes de rodar os testes, lembra?</p>\n<p>Depois de entender tudo isso fez sentido, eu não preciso ter um array de models reais\npra meus dados falsos antes de criá-los, eu posso ter um array de dicts e na hora de inserir no banco que crio o objeto de verdade, então por fim a solução foi:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #24292EFF\">users </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> [</span>\n<span style=\"color: #24292EFF\">    {</span><span style=\"color: #22863A\">\"id\"</span><span style=\"color: #24292EFF\">:</span><span style=\"color: #1976D2\">1</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"name\"</span><span style=\"color: #24292EFF\">:</span><span style=\"color: #22863A\">\"ABC\"</span><span style=\"color: #24292EFF\">},</span>\n<span style=\"color: #24292EFF\">    {</span><span style=\"color: #22863A\">\"id\"</span><span style=\"color: #24292EFF\">:</span><span style=\"color: #1976D2\">1</span><span style=\"color: #24292EFF\">, </span><span style=\"color: #22863A\">\"name\"</span><span style=\"color: #24292EFF\">:</span><span style=\"color: #22863A\">\"XYZ\"</span><span style=\"color: #24292EFF\">},</span>\n<span style=\"color: #24292EFF\">]</span></code></pre>\n<p>E na minha fixture:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span style=\"color: #D32F2F\">for</span><span style=\"color: #24292EFF\"> user </span><span style=\"color: #D32F2F\">in</span><span style=\"color: #24292EFF\"> users:</span>\n<span style=\"color: #24292EFF\">    new_user </span><span style=\"color: #D32F2F\">=</span><span style=\"color: #24292EFF\"> </span><span style=\"color: #6F42C1\">MyModel(</span><span style=\"color: #D32F2F\">**</span><span style=\"color: #6F42C1\">user)</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">add(new_user)</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">commit()</span>\n<span style=\"color: #24292EFF\">    db.</span><span style=\"color: #6F42C1\">refresh(new_user)</span></code></pre>\n<p>Pronto, agora sim posso ter mil testes todos isolados com o banco limpo e dados\ninciais antes de rodar :)</p>\n<h2 id=\"conclusão\"><a href=\"#conclus%C3%A3o\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusão</h2>\n<p>Ficar na superfície pode cobrir a maior parte dos casos, mas assim que precisamos de algo que foge do básico ou da configuração que \"vem pronta\" (mesmo que não seja nada extraordinário, como foi meu caso), não tem stackoverflow que salve e precisamos entender de fato o que está acontecendo por baixo dos panos. Pra mim o combo ler documentação + um bom tempo com debug e experimentação é a melhor forma de aprender.</p>\n<p>Agora posso finalemente focar em escrever os testes de fato e garantir que minha aplicação funciona como esperado.</p>\n<hr>\n<p>Se eu falei alguma bobeira ou você sabe uma forma melhor de solucionar os casos\nque mencionei no post, deixa seu comentário aí embaixo ;)</p>\n","excerpt":"","description":"","author":{"id":"anarute","title":"anarute","path":"/author/anarute/"}}}]}}},"context":{}}