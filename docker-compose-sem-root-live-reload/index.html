<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" class="h-full" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D,%22class%22:%7B%22ssr%22:%22h-full%22%7D%7D">
  <head>
    <title>Rodando docker compose sem root e containers com live-reload no Fedora  | Ana Rute</title><meta name="gridsome:hash" content="752c6ce69aa6bc2761e11346ad248f842b46c834"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:
monolito legado, novo front end em React e nova API com FastAPI. Com a chegada
de uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas
as aplicações juntas, incluindo o banco de dado ..."><meta data-vue-tag="ssr" property="og:type" content="article"><meta data-vue-tag="ssr" property="og:title" content="Rodando docker compose sem root e containers com live-reload no Fedora"><meta data-vue-tag="ssr" property="og:description" content="Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:
monolito legado, novo front end em React e nova API com FastAPI. Com a chegada
de uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas
as aplicações juntas, incluindo o banco de dado ..."><meta data-vue-tag="ssr" property="og:url" content="https://anarute.com/docker-compose-sem-root-live-reload/"><meta data-vue-tag="ssr" property="article:published_time" content="2023-08-14"><meta data-vue-tag="ssr" property="og:image" content="https://anarute.com/images/card.png"><meta data-vue-tag="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-tag="ssr" name="twitter:title" content="Rodando docker compose sem root e containers com live-reload no Fedora"><meta data-vue-tag="ssr" name="twitter:description" content="Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:
monolito legado, novo front end em React e nova API com FastAPI. Com a chegada
de uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas
as aplicações juntas, incluindo o banco de dado ..."><meta data-vue-tag="ssr" name="twitter:site" content="@ana_rute"><meta data-vue-tag="ssr" name="twitter:creator" content="@ana_rute"><meta data-vue-tag="ssr" name="twitter:image" content="https://anarute.com/images/card.png"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.1dbd3df5a133ad4bfceee6f845dec19f.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.1dbd3df5a133ad4bfceee6f845dec19f.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.1dbd3df5a133ad4bfceee6f845dec19f.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.1dbd3df5a133ad4bfceee6f845dec19f.png"><link data-vue-tag="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans:400,700%7CCardo"><link rel="preload" href="/assets/css/10.styles.71c6ed44.css" as="style"><link rel="preload" href="/assets/js/app.0aaf7b86.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.910010bc.js" as="script"><link rel="prefetch" href="/assets/js/12.bf723347.js"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.f874ac3a.js"><link rel="prefetch" href="/assets/js/page--src--pages--about-vue.d8cccfac.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.c4d60db6.js"><link rel="prefetch" href="/assets/js/page--src--pages--talks-vue.fb1d0092.js"><link rel="prefetch" href="/assets/js/page--src--pages--uses-vue.3f17494c.js"><link rel="prefetch" href="/assets/js/page--src--templates--author-vue.4fa776a2.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.18e80999.js"><link rel="prefetch" href="/assets/js/vendors~page--src--pages--index-vue~page--src--templates--author-vue~page--src--templates--post-vue~~a0fae544.81352eac.js"><link rel="prefetch" href="/assets/js/vendors~page--src--templates--post-vue.989aa289.js"><link rel="stylesheet" href="/assets/css/10.styles.71c6ed44.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body class="antialiased font-serif" data-vue-tag="%7B%22class%22:%7B%22ssr%22:%22antialiased%20font-serif%22%7D%7D">
    <div data-server-rendered="true" id="app" class="layout"><section class="menu"><div><nav><ul><li><a href="/" class="active">posts</a></li><li><a href="/about/">about</a></li><li><a href="/uses/">setup</a></li><li><a href="/talks/">talks</a></li><li><a href="/feed.xml">RSS Feed</a></li></ul></nav></div></section><main><header><div><div><h1>Rodando docker compose sem root e containers com live-reload no Fedora</h1><p><span><a href="/author/anarute/">anarute</a>
          •
        </span><time datetime="2023-08-14 10:00:00">14 August, 2023</time></p></div></div></header><article><!----><div><p>Nos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:
monolito legado, novo front end em React e nova API com FastAPI. Com a chegada
de uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas
as aplicações juntas, incluindo o banco de dados e aplicação de autenticação, o
que facilitaria bastante o fluxo de desenvolvimento por não ter que configurar
manualmente todas as aplicações nem ter que subir uma por uma toda vez.</p>
<p>Meu principal requisito era criar um docker-compose de modo que os serviços
fossem atualizados automaticamente sem precisar buildar o container a cada
mudança, vulgo <strong>live-reload</strong>. O método que escolhi pra fazer isso foi com
volumes, já que pareceu a opção mais natural: docker espelha os arquivos de uma
pasta local com os arquivos do ambiente docker, assim qualquer modificação nos
volumes serão compartilhadas com os containers sem a necessidade de
reconstruir-los.</p>
<p>Como um teste simples inicial, criei uma aplicação com FastAPI, com um único
endpoint o mais simples possível:</p>
<pre class="shiki" style="background-color: #ffffff"><code><span style="color: #6A737D"># src/main.py`</span>

<span style="color: #D32F2F">from</span><span style="color: #24292EFF"> typing </span><span style="color: #D32F2F">import</span><span style="color: #24292EFF"> Optional</span>
<span style="color: #D32F2F">from</span><span style="color: #24292EFF"> fastapi </span><span style="color: #D32F2F">import</span><span style="color: #24292EFF"> FastAPI</span>

<span style="color: #24292EFF">app </span><span style="color: #D32F2F">=</span><span style="color: #24292EFF"> </span><span style="color: #6F42C1">FastAPI()</span>

<span style="color: #6F42C1">@app.get</span><span style="color: #24292EFF">(</span><span style="color: #22863A">"/"</span><span style="color: #24292EFF">)</span>
<span style="color: #D32F2F">def</span><span style="color: #24292EFF"> </span><span style="color: #6F42C1">read_root</span><span style="color: #24292EFF">():</span>
<span style="color: #24292EFF">    </span><span style="color: #D32F2F">return</span><span style="color: #24292EFF"> {</span><span style="color: #22863A">"Hello"</span><span style="color: #24292EFF">: </span><span style="color: #22863A">"World"</span><span style="color: #24292EFF">}</span></code></pre>
<p>O Dockerfile também super simples, seguindo os passos da <a href="https://fastapi.tiangolo.com/deployment/docker/" target="_blank" rel="nofollow noopener noreferrer">documentação do
FastAPI</a>:</p>
<pre class="shiki" style="background-color: #ffffff"><code><span style="color: #6A737D"># Dockerfile</span>

<span style="color: #24292EFF">FROM python:</span><span style="color: #1976D2">3.9</span>

<span style="color: #24292EFF">WORKDIR </span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">code</span>

<span style="color: #24292EFF">COPY .</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">requirements.txt </span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">code</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">requirements.txt</span>

<span style="color: #24292EFF">RUN pip install --no</span><span style="color: #D32F2F">-</span><span style="color: #24292EFF">cache</span><span style="color: #D32F2F">-</span><span style="color: #1976D2">dir</span><span style="color: #24292EFF"> --upgrade </span><span style="color: #D32F2F">-</span><span style="color: #24292EFF">r </span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">code</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">requirements.txt</span>

<span style="color: #24292EFF">COPY .</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">app </span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">code</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">app</span>

<span style="color: #24292EFF">EXPOSE </span><span style="color: #1976D2">8000</span>

<span style="color: #6A737D"># A opção --reload é que faz o servidor recarregar quando há mudanças nos arquivos</span>

<span style="color: #24292EFF">CMD [</span><span style="color: #22863A">"uvicorn"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"app.main:app"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"--reload"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"--host"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"0.0.0.0"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"--port"</span><span style="color: #24292EFF">, </span><span style="color: #22863A">"8000"</span><span style="color: #24292EFF">]</span></code></pre>
<p>E no docker-compose, o segredo tá na configuração dos volumes:</p>
<pre class="shiki" style="background-color: #ffffff"><code><span style="color: #6A737D"># docker-compose.yml</span>

<span style="color: #24292EFF">version: </span><span style="color: #22863A">'3.7'</span>

<span style="color: #24292EFF">services:</span>
<span style="color: #24292EFF">  server:</span>
<span style="color: #24292EFF">    container_name: server</span>
<span style="color: #24292EFF">    build:</span>
<span style="color: #24292EFF">      context: .</span>
<span style="color: #24292EFF">      dockerfile: Dockerfile</span>
<span style="color: #24292EFF">    volumes:</span>
<span style="color: #24292EFF">      </span><span style="color: #D32F2F">-</span><span style="color: #24292EFF"> .</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">app:</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">code</span><span style="color: #D32F2F">/</span><span style="color: #24292EFF">app</span>
<span style="color: #24292EFF">    ports:</span>
<span style="color: #24292EFF">      </span><span style="color: #D32F2F">-</span><span style="color: #24292EFF"> </span><span style="color: #22863A">"8008:8008"</span></code></pre>
<p>Aqui estamos dizendo que a pasta <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">app</code>, que nesse caso está no mesmo nível do
arquivo <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">docker-compose.yml</code> vai ser espelhada na pasta <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">/code/app</code> dentro do
container. Se você reparar no Dockerfile eu copio a pasta <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">./app</code> para
<code class="shiki-inline" style="background: #2e3440; color: #d8dee9">/code/app</code>, assim o conteúdo das duas deveria ser o mesmo e é exatamente onde
estão os arquivos que eu modifico e que gostaria durante o desenvolvimento e que
gostaria que o servidor recarregasse ao serem modificados.</p>
<p>A princípio isso deveria funcionar, encontrei vários exemplos que faziam
exatemente isso e pareciam bem simples, mas por algum motivo não funcionava pra
mim. Assim que eu configurava o volume, as aplicações não funcionavam mais e
investigando um pouco parecia que os arquivos ou não eram mais copiados para o
container ou o container não tinha permissão de lê-los.</p>
<p>Como eu uso Fedora, no lugar Docker eu uso Podman, mas para docker compose usava
o pacote <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">docker-compose</code> mesmo e tinha que rodar docker-compose com sudo, o que
não era exatamente ideal já que uma das melhores vantagens do podman (além de
ser open source) é a possibilidade de rodar docker sem root. Comecei a achar que
o problema deveria estar relacionado a isso, já que tinha cara de problema de
permissões. Depois de postergar por meses, resolvi finalmente parar pra resolver
isso e passar a rodar docker-compose sem root. Essa foi a primeira parte da
solução, o que eu não contava é que em um artigo só eu acharia a solução para os
dois problemas: <a href="https://brandonrozek.com/blog/rootless-docker-compose-podman/" target="_blank" rel="nofollow noopener noreferrer">https://brandonrozek.com/blog/rootless-docker-compose-podman/</a></p>
<p>A solução veio em duas etapas, passar a rodar o socket do podman como meu
usuário e não mais com root:</p>
<pre class="shiki" style="background-color: #ffffff"><code><span style="color: #24292EFF">systemctl --user </span><span style="color: #1976D2">enable</span><span style="color: #24292EFF"> podman.socket</span>
<span style="color: #24292EFF">systemctl --user start podman.socket</span>
<span style="color: #D32F2F">export</span><span style="color: #24292EFF"> DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock</span></code></pre>
<p>E no finalzinho do artigo, Brandon solta essa informação despretenciosamente que
foi o que me salvou:</p>
<blockquote>
<p>"If you want to add to add more volumes to the container, make sure it has the
appropriate SELinux label if you’re using a distribution with it enabled."</p>
</blockquote>
<p><code class="shiki-inline" style="background: #2e3440; color: #d8dee9">chcon -t container_file_t -R &lt;volume_name&gt;</code></p>
<p>No caso do meu exemplo, <code class="shiki-inline" style="background: #2e3440; color: #d8dee9">chcon -t container_file_t -R app</code> foi o que resolveu.</p>
<p>Eu quebrei muita a cabeça até achar essa solução e finalmente consigo rodar
docker-compose sem root e usar live-reload!</p>
<p>Segue o repositório bem simples com exemplo que descrevi:
<a href="https://github.com/anarute/fastapi-live-reload" target="_blank" rel="nofollow noopener noreferrer">https://github.com/anarute/fastapi-live-reload</a></p>
<p>Se quiser ler um pouco mais sobre, recomendo <a href="https://www.freecodecamp.org/news/how-to-enable-live-reload-on-docker-based-applications/" target="_blank" rel="nofollow noopener noreferrer">esse
artigo</a>
do Erick Wendel.</p>
</div><footer><div><a href="/tag/pt-br/" class="tag">
            pt-br
          </a><a href="/tag/docker/" class="tag">
            docker
          </a><a href="/tag/fedora/" class="tag">
            fedora
          </a></div></footer><div id="disqus_thread"></div></article></main></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Rodando docker compose sem root e containers com live-reload no Fedora","slug":"docker-compose-sem-root-live-reload","datetime":"2023-08-14 10:00:00","content":"\u003Cp\u003ENos últimos dias precisei dockerizar uma aplicação divida em 3 serviços:\nmonolito legado, novo front end em React e nova API com FastAPI. Com a chegada\nde uma nova pessoa no time, resolvemos criar um docker-compose que rodasse todas\nas aplicações juntas, incluindo o banco de dados e aplicação de autenticação, o\nque facilitaria bastante o fluxo de desenvolvimento por não ter que configurar\nmanualmente todas as aplicações nem ter que subir uma por uma toda vez.\u003C\u002Fp\u003E\n\u003Cp\u003EMeu principal requisito era criar um docker-compose de modo que os serviços\nfossem atualizados automaticamente sem precisar buildar o container a cada\nmudança, vulgo \u003Cstrong\u003Elive-reload\u003C\u002Fstrong\u003E. O método que escolhi pra fazer isso foi com\nvolumes, já que pareceu a opção mais natural: docker espelha os arquivos de uma\npasta local com os arquivos do ambiente docker, assim qualquer modificação nos\nvolumes serão compartilhadas com os containers sem a necessidade de\nreconstruir-los.\u003C\u002Fp\u003E\n\u003Cp\u003EComo um teste simples inicial, criei uma aplicação com FastAPI, com um único\nendpoint o mais simples possível:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #ffffff\"\u003E\u003Ccode\u003E\u003Cspan style=\"color: #6A737D\"\u003E# src\u002Fmain.py`\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #D32F2F\"\u003Efrom\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E typing \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003Eimport\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E Optional\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #D32F2F\"\u003Efrom\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E fastapi \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003Eimport\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E FastAPI\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003Eapp \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E=\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E \u003C\u002Fspan\u003E\u003Cspan style=\"color: #6F42C1\"\u003EFastAPI()\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #6F42C1\"\u003E@app.get\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E(\u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"\u002F\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #D32F2F\"\u003Edef\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E \u003C\u002Fspan\u003E\u003Cspan style=\"color: #6F42C1\"\u003Eread_root\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E():\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E    \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003Ereturn\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E {\u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"Hello\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E: \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"World\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EO Dockerfile também super simples, seguindo os passos da \u003Ca href=\"https:\u002F\u002Ffastapi.tiangolo.com\u002Fdeployment\u002Fdocker\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Edocumentação do\nFastAPI\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #ffffff\"\u003E\u003Ccode\u003E\u003Cspan style=\"color: #6A737D\"\u003E# Dockerfile\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003EFROM python:\u003C\u002Fspan\u003E\u003Cspan style=\"color: #1976D2\"\u003E3.9\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003EWORKDIR \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecode\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003ECOPY .\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Erequirements.txt \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecode\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Erequirements.txt\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003ERUN pip install --no\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E-\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecache\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E-\u003C\u002Fspan\u003E\u003Cspan style=\"color: #1976D2\"\u003Edir\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E --upgrade \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E-\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Er \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecode\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Erequirements.txt\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003ECOPY .\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Eapp \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecode\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Eapp\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003EEXPOSE \u003C\u002Fspan\u003E\u003Cspan style=\"color: #1976D2\"\u003E8000\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #6A737D\"\u003E# A opção --reload é que faz o servidor recarregar quando há mudanças nos arquivos\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003ECMD [\u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"uvicorn\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"app.main:app\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"--reload\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"--host\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"0.0.0.0\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"--port\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E, \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"8000\"\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E]\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EE no docker-compose, o segredo tá na configuração dos volumes:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #ffffff\"\u003E\u003Ccode\u003E\u003Cspan style=\"color: #6A737D\"\u003E# docker-compose.yml\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003Eversion: \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E'3.7'\u003C\u002Fspan\u003E\n\n\u003Cspan style=\"color: #24292EFF\"\u003Eservices:\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E  server:\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E    container_name: server\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E    build:\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E      context: .\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E      dockerfile: Dockerfile\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E    volumes:\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E      \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E-\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E .\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Eapp:\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Ecode\u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E\u002F\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003Eapp\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E    ports:\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003E      \u003C\u002Fspan\u003E\u003Cspan style=\"color: #D32F2F\"\u003E-\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E \u003C\u002Fspan\u003E\u003Cspan style=\"color: #22863A\"\u003E\"8008:8008\"\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAqui estamos dizendo que a pasta \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003Eapp\u003C\u002Fcode\u003E, que nesse caso está no mesmo nível do\narquivo \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003Edocker-compose.yml\u003C\u002Fcode\u003E vai ser espelhada na pasta \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003E\u002Fcode\u002Fapp\u003C\u002Fcode\u003E dentro do\ncontainer. Se você reparar no Dockerfile eu copio a pasta \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003E.\u002Fapp\u003C\u002Fcode\u003E para\n\u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003E\u002Fcode\u002Fapp\u003C\u002Fcode\u003E, assim o conteúdo das duas deveria ser o mesmo e é exatamente onde\nestão os arquivos que eu modifico e que gostaria durante o desenvolvimento e que\ngostaria que o servidor recarregasse ao serem modificados.\u003C\u002Fp\u003E\n\u003Cp\u003EA princípio isso deveria funcionar, encontrei vários exemplos que faziam\nexatemente isso e pareciam bem simples, mas por algum motivo não funcionava pra\nmim. Assim que eu configurava o volume, as aplicações não funcionavam mais e\ninvestigando um pouco parecia que os arquivos ou não eram mais copiados para o\ncontainer ou o container não tinha permissão de lê-los.\u003C\u002Fp\u003E\n\u003Cp\u003EComo eu uso Fedora, no lugar Docker eu uso Podman, mas para docker compose usava\no pacote \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003Edocker-compose\u003C\u002Fcode\u003E mesmo e tinha que rodar docker-compose com sudo, o que\nnão era exatamente ideal já que uma das melhores vantagens do podman (além de\nser open source) é a possibilidade de rodar docker sem root. Comecei a achar que\no problema deveria estar relacionado a isso, já que tinha cara de problema de\npermissões. Depois de postergar por meses, resolvi finalmente parar pra resolver\nisso e passar a rodar docker-compose sem root. Essa foi a primeira parte da\nsolução, o que eu não contava é que em um artigo só eu acharia a solução para os\ndois problemas: \u003Ca href=\"https:\u002F\u002Fbrandonrozek.com\u002Fblog\u002Frootless-docker-compose-podman\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fbrandonrozek.com\u002Fblog\u002Frootless-docker-compose-podman\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EA solução veio em duas etapas, passar a rodar o socket do podman como meu\nusuário e não mais com root:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #ffffff\"\u003E\u003Ccode\u003E\u003Cspan style=\"color: #24292EFF\"\u003Esystemctl --user \u003C\u002Fspan\u003E\u003Cspan style=\"color: #1976D2\"\u003Eenable\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E podman.socket\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #24292EFF\"\u003Esystemctl --user start podman.socket\u003C\u002Fspan\u003E\n\u003Cspan style=\"color: #D32F2F\"\u003Eexport\u003C\u002Fspan\u003E\u003Cspan style=\"color: #24292EFF\"\u003E DOCKER_HOST=unix:\u002F\u002F\u002Frun\u002Fuser\u002F$UID\u002Fpodman\u002Fpodman.sock\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EE no finalzinho do artigo, Brandon solta essa informação despretenciosamente que\nfoi o que me salvou:\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\"If you want to add to add more volumes to the container, make sure it has the\nappropriate SELinux label if you’re using a distribution with it enabled.\"\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003Echcon -t container_file_t -R &lt;volume_name&gt;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENo caso do meu exemplo, \u003Ccode class=\"shiki-inline\" style=\"background: #2e3440; color: #d8dee9\"\u003Echcon -t container_file_t -R app\u003C\u002Fcode\u003E foi o que resolveu.\u003C\u002Fp\u003E\n\u003Cp\u003EEu quebrei muita a cabeça até achar essa solução e finalmente consigo rodar\ndocker-compose sem root e usar live-reload!\u003C\u002Fp\u003E\n\u003Cp\u003ESegue o repositório bem simples com exemplo que descrevi:\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fanarute\u002Ffastapi-live-reload\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fgithub.com\u002Fanarute\u002Ffastapi-live-reload\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESe quiser ler um pouco mais sobre, recomendo \u003Ca href=\"https:\u002F\u002Fwww.freecodecamp.org\u002Fnews\u002Fhow-to-enable-live-reload-on-docker-based-applications\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Eesse\nartigo\u003C\u002Fa\u003E\ndo Erick Wendel.\u003C\u002Fp\u003E\n","description":"","cover":"","fullscreen":false,"author":{"id":"anarute","title":"anarute","path":"\u002Fauthor\u002Fanarute\u002F"},"tags":[{"id":"pt-br","title":"pt-br","path":"\u002Ftag\u002Fpt-br\u002F"},{"id":"docker","title":"docker","path":"\u002Ftag\u002Fdocker\u002F"},{"id":"fedora","title":"fedora","path":"\u002Ftag\u002Ffedora\u002F"}]}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.0aaf7b86.js" defer></script><script src="/assets/js/page--src--templates--post-vue.910010bc.js" defer></script>
  </body>
</html>
